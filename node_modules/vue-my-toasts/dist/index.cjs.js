/*!
  * vue-my-toasts v2.0.0
  * (c) 2021 
  * @license MIT
  */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueDemi = require('vue-demi');

/**
 * Get a toast uuid, useful when no `id` is provided by the user.
 *
 * @returns {string}
 */
var getUuid = () => {
    return 'toast-' + Date.now() + '-' + Math.floor(Math.random() * 10);
};

const isClient = typeof window !== 'undefined';
const toString = Object.prototype.toString;
const isNumber = (val) => typeof val === 'number';
const isString$2 = (val) => typeof val === 'string';
const isObject = (val) => toString.call(val) === '[object Object]';
const noop = () => { };

/**
 * Call onUnmounted() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
function tryOnUnmounted(fn) {
    if (vueDemi.getCurrentInstance())
        vueDemi.onUnmounted(fn);
}

const defaultWindow = /* #__PURE__ */ isClient ? window : undefined;

/**
 * Get the dom element of a ref of element or Vue component instance
 *
 * @param elRef
 */
function unrefElement(elRef) {
    var _a, _b;
    const plain = vueDemi.unref(elRef);
    return (_b = (_a = plain) === null || _a === void 0 ? void 0 : _a.$el) !== null && _b !== void 0 ? _b : plain;
}

function useEventListener(...args) {
    let target;
    let event;
    let listener;
    let options;
    if (isString$2(args[0])) {
        [event, listener, options] = args;
        target = defaultWindow;
    }
    else {
        [target, event, listener, options] = args;
    }
    if (!target)
        return noop;
    let cleanup = noop;
    const stopWatch = vueDemi.watch(() => vueDemi.unref(target), (el) => {
        cleanup();
        if (!el)
            return;
        el.addEventListener(event, listener, options);
        cleanup = () => {
            el.removeEventListener(event, listener, options);
            cleanup = noop;
        };
    }, { immediate: true, flush: 'post' });
    const stop = () => {
        stopWatch();
        cleanup();
    };
    tryOnUnmounted(stop);
    return stop;
}

/**
 * Detects that a target element's visibility.
 *
 * @link https://vueuse.org/useIntersectionObserver
 * @param target
 * @param callback
 * @param options
 */
function useIntersectionObserver(target, callback, options = {}) {
    const { root, rootMargin = '0px', threshold = 0.1, window = defaultWindow, } = options;
    const isSupported = window && 'IntersectionObserver' in window;
    let cleanup = noop;
    const stopWatch = isSupported
        ? vueDemi.watch(() => ({
            el: unrefElement(target),
            root: unrefElement(root),
        }), ({ el, root }) => {
            cleanup();
            if (!el)
                return;
            // @ts-expect-error missing type
            const observer = new window.IntersectionObserver(callback, {
                root,
                rootMargin,
                threshold,
            });
            observer.observe(el);
            cleanup = () => {
                observer.disconnect();
                cleanup = noop;
            };
        }, { immediate: true, flush: 'post' })
        : noop;
    const stop = () => {
        cleanup();
        stopWatch();
    };
    tryOnUnmounted(stop);
    return {
        isSupported,
        stop,
    };
}

var SwipeDirection;
(function (SwipeDirection) {
    SwipeDirection["UP"] = "UP";
    SwipeDirection["RIGHT"] = "RIGHT";
    SwipeDirection["DOWN"] = "DOWN";
    SwipeDirection["LEFT"] = "LEFT";
    SwipeDirection["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

var warning = function () { };
var invariant = function () { };
if (process.env.NODE_ENV !== 'production') {
    warning = function (check, message) {
        if (!check && typeof console !== 'undefined') {
            console.warn(message);
        }
    };
    invariant = function (check, message) {
        if (!check) {
            throw new Error(message);
        }
    };
}

var clamp$2 = function (min, max, v) {
    return Math.min(Math.max(v, min), max);
};

var safeMin = 0.001;
var minDuration = 0.01;
var maxDuration = 10.0;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring(_a) {
    var _b = _a.duration, duration = _b === void 0 ? 800 : _b, _c = _a.bounce, bounce = _c === void 0 ? 0.25 : _c, _d = _a.velocity, velocity = _d === void 0 ? 0 : _d, _e = _a.mass, mass = _e === void 0 ? 1 : _e;
    var envelope;
    var derivative;
    warning(duration <= maxDuration * 1000, "Spring duration must be 10 seconds or less");
    var dampingRatio = 1 - bounce;
    dampingRatio = clamp$2(minDamping, maxDamping, dampingRatio);
    duration = clamp$2(minDuration, maxDuration, duration / 1000);
    if (dampingRatio < 1) {
        envelope = function (undampedFreq) {
            var exponentialDecay = undampedFreq * dampingRatio;
            var delta = exponentialDecay * duration;
            var a = exponentialDecay - velocity;
            var b = calcAngularFreq(undampedFreq, dampingRatio);
            var c = Math.exp(-delta);
            return safeMin - (a / b) * c;
        };
        derivative = function (undampedFreq) {
            var exponentialDecay = undampedFreq * dampingRatio;
            var delta = exponentialDecay * duration;
            var d = delta * velocity + velocity;
            var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
            var f = Math.exp(-delta);
            var g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
            var factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
            return (factor * ((d - e) * f)) / g;
        };
    }
    else {
        envelope = function (undampedFreq) {
            var a = Math.exp(-undampedFreq * duration);
            var b = (undampedFreq - velocity) * duration + 1;
            return -safeMin + a * b;
        };
        derivative = function (undampedFreq) {
            var a = Math.exp(-undampedFreq * duration);
            var b = (velocity - undampedFreq) * (duration * duration);
            return a * b;
        };
    }
    var initialGuess = 5 / duration;
    var undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    if (isNaN(undampedFreq)) {
        return {
            stiffness: 100,
            damping: 10,
        };
    }
    else {
        var stiffness = Math.pow(undampedFreq, 2) * mass;
        return {
            stiffness: stiffness,
            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        };
    }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
    var result = initialGuess;
    for (var i = 1; i < rootIterations; i++) {
        result = result - envelope(result) / derivative(result);
    }
    return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
    return keys.some(function (key) { return options[key] !== undefined; });
}
function getSpringOptions(options) {
    var springOptions = __assign$1({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);
    if (!isSpringType(options, physicsKeys) &&
        isSpringType(options, durationKeys)) {
        var derived = findSpring(options);
        springOptions = __assign$1(__assign$1(__assign$1({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });
        springOptions.isResolvedFromDuration = true;
    }
    return springOptions;
}
function spring(_a) {
    var _b = _a.from, from = _b === void 0 ? 0.0 : _b, _c = _a.to, to = _c === void 0 ? 1.0 : _c, _d = _a.restSpeed, restSpeed = _d === void 0 ? 2 : _d, restDelta = _a.restDelta, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
    var state = { done: false, value: from };
    var _e = getSpringOptions(options), stiffness = _e.stiffness, damping = _e.damping, mass = _e.mass, velocity = _e.velocity, isResolvedFromDuration = _e.isResolvedFromDuration;
    var resolveSpring = zero;
    var resolveVelocity = zero;
    function createSpring() {
        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;
        var initialDelta = to - from;
        var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
        var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;
        restDelta !== null && restDelta !== void 0 ? restDelta : (restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4);
        if (dampingRatio < 1) {
            var angularFreq_1 = calcAngularFreq(undampedAngularFreq, dampingRatio);
            resolveSpring = function (t) {
                var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
                return (to -
                    envelope *
                        (((initialVelocity +
                            dampingRatio * undampedAngularFreq * initialDelta) /
                            angularFreq_1) *
                            Math.sin(angularFreq_1 * t) +
                            initialDelta * Math.cos(angularFreq_1 * t)));
            };
            resolveVelocity = function (t) {
                var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
                return (dampingRatio *
                    undampedAngularFreq *
                    envelope *
                    ((Math.sin(angularFreq_1 * t) *
                        (initialVelocity +
                            dampingRatio *
                                undampedAngularFreq *
                                initialDelta)) /
                        angularFreq_1 +
                        initialDelta * Math.cos(angularFreq_1 * t)) -
                    envelope *
                        (Math.cos(angularFreq_1 * t) *
                            (initialVelocity +
                                dampingRatio *
                                    undampedAngularFreq *
                                    initialDelta) -
                            angularFreq_1 *
                                initialDelta *
                                Math.sin(angularFreq_1 * t)));
            };
        }
        else if (dampingRatio === 1) {
            resolveSpring = function (t) {
                return to -
                    Math.exp(-undampedAngularFreq * t) *
                        (initialDelta +
                            (initialVelocity + undampedAngularFreq * initialDelta) *
                                t);
            };
        }
        else {
            var dampedAngularFreq_1 = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
            resolveSpring = function (t) {
                var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
                var freqForT = Math.min(dampedAngularFreq_1 * t, 300);
                return (to -
                    (envelope *
                        ((initialVelocity +
                            dampingRatio * undampedAngularFreq * initialDelta) *
                            Math.sinh(freqForT) +
                            dampedAngularFreq_1 *
                                initialDelta *
                                Math.cosh(freqForT))) /
                        dampedAngularFreq_1);
            };
        }
    }
    createSpring();
    return {
        next: function (t) {
            var current = resolveSpring(t);
            if (!isResolvedFromDuration) {
                var currentVelocity = resolveVelocity(t) * 1000;
                var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
                var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
                state.done =
                    isBelowVelocityThreshold && isBelowDisplacementThreshold;
            }
            else {
                state.done = t >= options.duration;
            }
            state.value = state.done ? to : current;
            return state;
        },
        flipTarget: function () {
            var _a;
            velocity = -velocity;
            _a = [to, from], from = _a[0], to = _a[1];
            createSpring();
        },
    };
}
spring.needsInterpolation = function (a, b) {
    return typeof a === "string" || typeof b === "string";
};
var zero = function (_t) { return 0; };

var progress = function (from, to, value) {
    var toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};

var mix = function (from, to, progress) {
    return -progress * from + progress * to + from;
};

var clamp$1 = function (min, max) { return function (v) {
    return Math.max(Math.min(v, max), min);
}; };
var sanitize$1 = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };
var floatRegex$1 = /(-)?([\d]*\.?[\d])+/g;
var colorRegex$1 = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex$1 = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString$1(v) {
    return typeof v === 'string';
}

var number$1 = {
    test: function (v) { return typeof v === 'number'; },
    parse: parseFloat,
    transform: function (v) { return v; },
};
var alpha$1 = __assign$1(__assign$1({}, number$1), { transform: clamp$1(0, 1) });
__assign$1(__assign$1({}, number$1), { default: 1 });

var createUnitType$1 = function (unit) { return ({
    test: function (v) {
        return isString$1(v) && v.endsWith(unit) && v.split(' ').length === 1;
    },
    parse: parseFloat,
    transform: function (v) { return "" + v + unit; },
}); };
var percent$1 = createUnitType$1('%');
__assign$1(__assign$1({}, percent$1), { parse: function (v) { return percent$1.parse(v) / 100; }, transform: function (v) { return percent$1.transform(v * 100); } });

var isColorString$1 = function (type, testProp) { return function (v) {
    return Boolean((isString$1(v) && singleColorRegex$1.test(v) && v.startsWith(type)) ||
        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));
}; };
var splitColor$1 = function (aName, bName, cName) { return function (v) {
    var _a;
    if (!isString$1(v))
        return v;
    var _b = v.match(floatRegex$1), a = _b[0], b = _b[1], c = _b[2], alpha = _b[3];
    return _a = {},
        _a[aName] = parseFloat(a),
        _a[bName] = parseFloat(b),
        _a[cName] = parseFloat(c),
        _a.alpha = alpha !== undefined ? parseFloat(alpha) : 1,
        _a;
}; };

var hsla$1 = {
    test: isColorString$1('hsl', 'hue'),
    parse: splitColor$1('hue', 'saturation', 'lightness'),
    transform: function (_a) {
        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1$1 = _b === void 0 ? 1 : _b;
        return ('hsla(' +
            Math.round(hue) +
            ', ' +
            percent$1.transform(sanitize$1(saturation)) +
            ', ' +
            percent$1.transform(sanitize$1(lightness)) +
            ', ' +
            sanitize$1(alpha$1.transform(alpha$1$1)) +
            ')');
    },
};

var clampRgbUnit$1 = clamp$1(0, 255);
var rgbUnit$1 = __assign$1(__assign$1({}, number$1), { transform: function (v) { return Math.round(clampRgbUnit$1(v)); } });
var rgba$1 = {
    test: isColorString$1('rgb', 'red'),
    parse: splitColor$1('red', 'green', 'blue'),
    transform: function (_a) {
        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1$1 = _b === void 0 ? 1 : _b;
        return 'rgba(' +
            rgbUnit$1.transform(red) +
            ', ' +
            rgbUnit$1.transform(green) +
            ', ' +
            rgbUnit$1.transform(blue) +
            ', ' +
            sanitize$1(alpha$1.transform(alpha$1$1)) +
            ')';
    },
};

function parseHex$1(v) {
    var r = '';
    var g = '';
    var b = '';
    var a = '';
    if (v.length > 5) {
        r = v.substr(1, 2);
        g = v.substr(3, 2);
        b = v.substr(5, 2);
        a = v.substr(7, 2);
    }
    else {
        r = v.substr(1, 1);
        g = v.substr(2, 1);
        b = v.substr(3, 1);
        a = v.substr(4, 1);
        r += r;
        g += g;
        b += b;
        a += a;
    }
    return {
        red: parseInt(r, 16),
        green: parseInt(g, 16),
        blue: parseInt(b, 16),
        alpha: a ? parseInt(a, 16) / 255 : 1,
    };
}
var hex$1 = {
    test: isColorString$1('#'),
    parse: parseHex$1,
    transform: rgba$1.transform,
};

var color$1 = {
    test: function (v) { return rgba$1.test(v) || hex$1.test(v) || hsla$1.test(v); },
    parse: function (v) {
        if (rgba$1.test(v)) {
            return rgba$1.parse(v);
        }
        else if (hsla$1.test(v)) {
            return hsla$1.parse(v);
        }
        else {
            return hex$1.parse(v);
        }
    },
    transform: function (v) {
        return isString$1(v)
            ? v
            : v.hasOwnProperty('red')
                ? rgba$1.transform(v)
                : hsla$1.transform(v);
    },
};

var colorToken$1 = '${c}';
var numberToken$1 = '${n}';
function test$1(v) {
    var _a, _b, _c, _d;
    return (isNaN(v) &&
        isString$1(v) &&
        ((_b = (_a = v.match(floatRegex$1)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex$1)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0);
}
function analyse$2(v) {
    var values = [];
    var numColors = 0;
    var colors = v.match(colorRegex$1);
    if (colors) {
        numColors = colors.length;
        v = v.replace(colorRegex$1, colorToken$1);
        values.push.apply(values, colors.map(color$1.parse));
    }
    var numbers = v.match(floatRegex$1);
    if (numbers) {
        v = v.replace(floatRegex$1, numberToken$1);
        values.push.apply(values, numbers.map(number$1.parse));
    }
    return { values: values, numColors: numColors, tokenised: v };
}
function parse$1(v) {
    return analyse$2(v).values;
}
function createTransformer$1(v) {
    var _a = analyse$2(v), values = _a.values, numColors = _a.numColors, tokenised = _a.tokenised;
    var numValues = values.length;
    return function (v) {
        var output = tokenised;
        for (var i = 0; i < numValues; i++) {
            output = output.replace(i < numColors ? colorToken$1 : numberToken$1, i < numColors ? color$1.transform(v[i]) : sanitize$1(v[i]));
        }
        return output;
    };
}
var convertNumbersToZero$1 = function (v) {
    return typeof v === 'number' ? 0 : v;
};
function getAnimatableNone$2(v) {
    var parsed = parse$1(v);
    var transformer = createTransformer$1(v);
    return transformer(parsed.map(convertNumbersToZero$1));
}
var complex$1 = { test: test$1, parse: parse$1, createTransformer: createTransformer$1, getAnimatableNone: getAnimatableNone$2 };

var mixLinearColor = function (from, to, v) {
    var fromExpo = from * from;
    var toExpo = to * to;
    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex$1, rgba$1, hsla$1];
var getColorType = function (v) {
    return colorTypes.find(function (type) { return type.test(v); });
};
var notAnimatable = function (color) {
    return "'" + color + "' is not an animatable color. Use the equivalent color code instead.";
};
var mixColor = function (from, to) {
    var fromColorType = getColorType(from);
    var toColorType = getColorType(to);
    invariant(!!fromColorType, notAnimatable(from));
    invariant(!!toColorType, notAnimatable(to));
    invariant(fromColorType.transform === toColorType.transform, "Both colors must be hex/RGBA, OR both must be HSLA.");
    var fromColor = fromColorType.parse(from);
    var toColor = toColorType.parse(to);
    var blended = __assign$1({}, fromColor);
    var mixFunc = fromColorType === hsla$1 ? mix : mixLinearColor;
    return function (v) {
        for (var key in blended) {
            if (key !== "alpha") {
                blended[key] = mixFunc(fromColor[key], toColor[key], v);
            }
        }
        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
        return fromColorType.transform(blended);
    };
};

var isNum = function (v) { return typeof v === 'number'; };

var combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };
var pipe = function () {
    var transformers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transformers[_i] = arguments[_i];
    }
    return transformers.reduce(combineFunctions);
};

function getMixer(origin, target) {
    if (isNum(origin)) {
        return function (v) { return mix(origin, target, v); };
    }
    else if (color$1.test(origin)) {
        return mixColor(origin, target);
    }
    else {
        return mixComplex(origin, target);
    }
}
var mixArray = function (from, to) {
    var output = __spreadArray([], from);
    var numValues = output.length;
    var blendValue = from.map(function (fromThis, i) { return getMixer(fromThis, to[i]); });
    return function (v) {
        for (var i = 0; i < numValues; i++) {
            output[i] = blendValue[i](v);
        }
        return output;
    };
};
var mixObject = function (origin, target) {
    var output = __assign$1(__assign$1({}, origin), target);
    var blendValue = {};
    for (var key in output) {
        if (origin[key] !== undefined && target[key] !== undefined) {
            blendValue[key] = getMixer(origin[key], target[key]);
        }
    }
    return function (v) {
        for (var key in blendValue) {
            output[key] = blendValue[key](v);
        }
        return output;
    };
};
function analyse$1(value) {
    var parsed = complex$1.parse(value);
    var numValues = parsed.length;
    var numNumbers = 0;
    var numRGB = 0;
    var numHSL = 0;
    for (var i = 0; i < numValues; i++) {
        if (numNumbers || typeof parsed[i] === "number") {
            numNumbers++;
        }
        else {
            if (parsed[i].hue !== undefined) {
                numHSL++;
            }
            else {
                numRGB++;
            }
        }
    }
    return { parsed: parsed, numNumbers: numNumbers, numRGB: numRGB, numHSL: numHSL };
}
var mixComplex = function (origin, target) {
    var template = complex$1.createTransformer(target);
    var originStats = analyse$1(origin);
    var targetStats = analyse$1(target);
    invariant(originStats.numHSL === targetStats.numHSL &&
        originStats.numRGB === targetStats.numRGB &&
        originStats.numNumbers >= targetStats.numNumbers, "Complex values '" + origin + "' and '" + target + "' too different to mix. Ensure all colors are of the same type.");
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
};

var mixNumber = function (from, to) { return function (p) { return mix(from, to, p); }; };
function detectMixerFactory(v) {
    if (typeof v === 'number') {
        return mixNumber;
    }
    else if (typeof v === 'string') {
        if (color$1.test(v)) {
            return mixColor;
        }
        else {
            return mixComplex;
        }
    }
    else if (Array.isArray(v)) {
        return mixArray;
    }
    else if (typeof v === 'object') {
        return mixObject;
    }
}
function createMixers(output, ease, customMixer) {
    var mixers = [];
    var mixerFactory = customMixer || detectMixerFactory(output[0]);
    var numMixers = output.length - 1;
    for (var i = 0; i < numMixers; i++) {
        var mixer = mixerFactory(output[i], output[i + 1]);
        if (ease) {
            var easingFunction = Array.isArray(ease) ? ease[i] : ease;
            mixer = pipe(easingFunction, mixer);
        }
        mixers.push(mixer);
    }
    return mixers;
}
function fastInterpolate(_a, _b) {
    var from = _a[0], to = _a[1];
    var mixer = _b[0];
    return function (v) { return mixer(progress(from, to, v)); };
}
function slowInterpolate(input, mixers) {
    var inputLength = input.length;
    var lastInputIndex = inputLength - 1;
    return function (v) {
        var mixerIndex = 0;
        var foundMixerIndex = false;
        if (v <= input[0]) {
            foundMixerIndex = true;
        }
        else if (v >= input[lastInputIndex]) {
            mixerIndex = lastInputIndex - 1;
            foundMixerIndex = true;
        }
        if (!foundMixerIndex) {
            var i = 1;
            for (; i < inputLength; i++) {
                if (input[i] > v || i === lastInputIndex) {
                    break;
                }
            }
            mixerIndex = i - 1;
        }
        var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
        return mixers[mixerIndex](progressInRange);
    };
}
function interpolate(input, output, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.clamp, isClamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;
    var inputLength = input.length;
    invariant(inputLength === output.length, 'Both input and output ranges must be the same length');
    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');
    if (input[0] > input[inputLength - 1]) {
        input = [].concat(input);
        output = [].concat(output);
        input.reverse();
        output.reverse();
    }
    var mixers = createMixers(output, ease, mixer);
    var interpolator = inputLength === 2
        ? fastInterpolate(input, mixers)
        : slowInterpolate(input, mixers);
    return isClamp
        ? function (v) { return interpolator(clamp$2(input[0], input[inputLength - 1], v)); }
        : interpolator;
}

var reverseEasing = function (easing) { return function (p) { return 1 - easing(1 - p); }; };
var mirrorEasing = function (easing) { return function (p) {
    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
}; };
var createExpoIn = function (power) { return function (p) { return Math.pow(p, power); }; };
var createBackIn = function (power) { return function (p) {
    return p * p * ((power + 1) * p - power);
}; };
var createAnticipate = function (power) {
    var backEasing = createBackIn(power);
    return function (p) {
        return (p *= 2) < 1
            ? 0.5 * backEasing(p)
            : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
    };
};

var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;
var BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;
var BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;
var linear = function (p) { return p; };
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = function (p) { return 1 - Math.sin(Math.acos(p)); };
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356.0 / 361.0;
var cb = 35442.0 / 1805.0;
var cc = 16061.0 / 1805.0;
var bounceOut = function (p) {
    if (p === 1 || p === 0)
        return p;
    var p2 = p * p;
    return p < BOUNCE_FIRST_THRESHOLD
        ? 7.5625 * p2
        : p < BOUNCE_SECOND_THRESHOLD
            ? 9.075 * p2 - 9.9 * p + 3.4
            : p < BOUNCE_THIRD_THRESHOLD
                ? ca * p2 - cb * p + cc
                : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = function (p) {
    return p < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))
        : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;
};

function defaultEasing(values, easing) {
    return values.map(function () { return easing || easeInOut; }).splice(0, values.length - 1);
}
function defaultOffset(values) {
    var numValues = values.length;
    return values.map(function (_value, i) {
        return i !== 0 ? i / (numValues - 1) : 0;
    });
}
function convertOffsetToTimes(offset, duration) {
    return offset.map(function (o) { return o * duration; });
}
function keyframes$1(_a) {
    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, ease = _a.ease, offset = _a.offset, _d = _a.duration, duration = _d === void 0 ? 300 : _d;
    var state = { done: false, value: from };
    var values = Array.isArray(to) ? to : [from, to];
    var times = convertOffsetToTimes(offset && offset.length === values.length
        ? offset
        : defaultOffset(values), duration);
    function createInterpolator() {
        return interpolate(times, values, {
            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),
        });
    }
    var interpolator = createInterpolator();
    return {
        next: function (t) {
            state.value = interpolator(t);
            state.done = t >= duration;
            return state;
        },
        flipTarget: function () {
            values.reverse();
            interpolator = createInterpolator();
        },
    };
}

function decay(_a) {
    var _b = _a.velocity, velocity = _b === void 0 ? 0 : _b, _c = _a.from, from = _c === void 0 ? 0 : _c, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 350 : _e, _f = _a.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = _a.modifyTarget;
    var state = { done: false, value: from };
    var amplitude = power * velocity;
    var ideal = from + amplitude;
    var target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
    if (target !== ideal)
        amplitude = target - from;
    return {
        next: function (t) {
            var delta = -amplitude * Math.exp(-t / timeConstant);
            state.done = !(delta > restDelta || delta < -restDelta);
            state.value = state.done ? target : target + delta;
            return state;
        },
        flipTarget: function () { },
    };
}

var types = { keyframes: keyframes$1, spring: spring, decay: decay };
function detectAnimationFromOptions(config) {
    if (Array.isArray(config.to)) {
        return keyframes$1;
    }
    else if (types[config.type]) {
        return types[config.type];
    }
    var keys = new Set(Object.keys(config));
    if (keys.has("ease") ||
        (keys.has("duration") && !keys.has("dampingRatio"))) {
        return keyframes$1;
    }
    else if (keys.has("dampingRatio") ||
        keys.has("stiffness") ||
        keys.has("mass") ||
        keys.has("damping") ||
        keys.has("restSpeed") ||
        keys.has("restDelta")) {
        return spring;
    }
    return keyframes$1;
}

var defaultTimestep$1 = (1 / 60) * 1000;
var getCurrentTime$1 = typeof performance !== "undefined"
    ? function () { return performance.now(); }
    : function () { return Date.now(); };
var onNextFrame$1 = typeof window !== "undefined"
    ? function (callback) {
        return window.requestAnimationFrame(callback);
    }
    : function (callback) {
        return setTimeout(function () { return callback(getCurrentTime$1()); }, defaultTimestep$1);
    };

function createRenderStep$1(runNextFrame) {
    var toRun = [];
    var toRunNextFrame = [];
    var numToRun = 0;
    var isProcessing = false;
    var toKeepAlive = new WeakSet();
    var step = {
        schedule: function (callback, keepAlive, immediate) {
            if (keepAlive === void 0) { keepAlive = false; }
            if (immediate === void 0) { immediate = false; }
            var addToCurrentFrame = immediate && isProcessing;
            var buffer = addToCurrentFrame ? toRun : toRunNextFrame;
            if (keepAlive)
                toKeepAlive.add(callback);
            if (buffer.indexOf(callback) === -1) {
                buffer.push(callback);
                if (addToCurrentFrame && isProcessing)
                    numToRun = toRun.length;
            }
            return callback;
        },
        cancel: function (callback) {
            var index = toRunNextFrame.indexOf(callback);
            if (index !== -1)
                toRunNextFrame.splice(index, 1);
            toKeepAlive.delete(callback);
        },
        process: function (frameData) {
            var _a;
            isProcessing = true;
            _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];
            toRunNextFrame.length = 0;
            numToRun = toRun.length;
            if (numToRun) {
                for (var i = 0; i < numToRun; i++) {
                    var callback = toRun[i];
                    callback(frameData);
                    if (toKeepAlive.has(callback)) {
                        step.schedule(callback);
                        runNextFrame();
                    }
                }
            }
            isProcessing = false;
        },
    };
    return step;
}

var maxElapsed$1 = 40;
var useDefaultElapsed$1 = true;
var runNextFrame$1 = false;
var isProcessing$1 = false;
var frame$1 = {
    delta: 0,
    timestamp: 0
};
var stepsOrder$1 = ["read", "update", "preRender", "render", "postRender"];
var steps$1 = /*#__PURE__*/stepsOrder$1.reduce(function (acc, key) {
    acc[key] = createRenderStep$1(function () {
        return runNextFrame$1 = true;
    });
    return acc;
}, {});
var sync$1 = /*#__PURE__*/stepsOrder$1.reduce(function (acc, key) {
    var step = steps$1[key];
    acc[key] = function (process, keepAlive, immediate) {
        if (keepAlive === void 0) {
            keepAlive = false;
        }
        if (immediate === void 0) {
            immediate = false;
        }
        if (!runNextFrame$1) startLoop$1();
        return step.schedule(process, keepAlive, immediate);
    };
    return acc;
}, {});
var cancelSync = /*#__PURE__*/stepsOrder$1.reduce(function (acc, key) {
    acc[key] = steps$1[key].cancel;
    return acc;
}, {});
var processStep$1 = function (stepId) {
    return steps$1[stepId].process(frame$1);
};
var processFrame$1 = function (timestamp) {
    runNextFrame$1 = false;
    frame$1.delta = useDefaultElapsed$1 ? defaultTimestep$1 : Math.max(Math.min(timestamp - frame$1.timestamp, maxElapsed$1), 1);
    frame$1.timestamp = timestamp;
    isProcessing$1 = true;
    stepsOrder$1.forEach(processStep$1);
    isProcessing$1 = false;
    if (runNextFrame$1) {
        useDefaultElapsed$1 = false;
        onNextFrame$1(processFrame$1);
    }
};
var startLoop$1 = function () {
    runNextFrame$1 = true;
    useDefaultElapsed$1 = true;
    if (!isProcessing$1) onNextFrame$1(processFrame$1);
};
var getFrameData$1 = function () {
    return frame$1;
};

function loopElapsed(elapsed, duration, delay) {
    if (delay === void 0) { delay = 0; }
    return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay, isForwardPlayback) {
    if (delay === void 0) { delay = 0; }
    if (isForwardPlayback === void 0) { isForwardPlayback = true; }
    return isForwardPlayback
        ? loopElapsed(duration + -elapsed, duration, delay)
        : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}

var framesync = function (update) {
    var passTimestamp = function (_a) {
        var delta = _a.delta;
        return update(delta);
    };
    return {
        start: function () { return sync$1.update(passTimestamp, true); },
        stop: function () { return cancelSync.update(passTimestamp); },
    };
};
function animate(_a) {
    var _b, _c;
    var from = _a.from, _d = _a.autoplay, autoplay = _d === void 0 ? true : _d, _e = _a.driver, driver = _e === void 0 ? framesync : _e, _f = _a.elapsed, elapsed = _f === void 0 ? 0 : _f, _g = _a.repeat, repeatMax = _g === void 0 ? 0 : _g, _h = _a.repeatType, repeatType = _h === void 0 ? "loop" : _h, _j = _a.repeatDelay, repeatDelay = _j === void 0 ? 0 : _j, onPlay = _a.onPlay, onStop = _a.onStop, onComplete = _a.onComplete, onRepeat = _a.onRepeat, onUpdate = _a.onUpdate, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
    var to = options.to;
    var driverControls;
    var repeatCount = 0;
    var computedDuration = options.duration;
    var latest;
    var isComplete = false;
    var isForwardPlayback = true;
    var interpolateFromNumber;
    var animator = detectAnimationFromOptions(options);
    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
        interpolateFromNumber = interpolate([0, 100], [from, to], {
            clamp: false,
        });
        from = 0;
        to = 100;
    }
    var animation = animator(__assign$1(__assign$1({}, options), { from: from, to: to }));
    function repeat() {
        repeatCount++;
        if (repeatType === "reverse") {
            isForwardPlayback = repeatCount % 2 === 0;
            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
        }
        else {
            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
            if (repeatType === "mirror")
                animation.flipTarget();
        }
        isComplete = false;
        onRepeat && onRepeat();
    }
    function complete() {
        driverControls.stop();
        onComplete && onComplete();
    }
    function update(delta) {
        if (!isForwardPlayback)
            delta = -delta;
        elapsed += delta;
        if (!isComplete) {
            var state = animation.next(Math.max(0, elapsed));
            latest = state.value;
            if (interpolateFromNumber)
                latest = interpolateFromNumber(latest);
            isComplete = isForwardPlayback ? state.done : elapsed <= 0;
        }
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
        if (isComplete) {
            if (repeatCount === 0)
                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);
            if (repeatCount < repeatMax) {
                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
            }
            else {
                complete();
            }
        }
    }
    function play() {
        onPlay === null || onPlay === void 0 ? void 0 : onPlay();
        driverControls = driver(update);
        driverControls.start();
    }
    autoplay && play();
    return {
        stop: function () {
            onStop === null || onStop === void 0 ? void 0 : onStop();
            driverControls.stop();
        },
    };
}

function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
}

function inertia(_a) {
    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 750 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget, driver = _a.driver, onUpdate = _a.onUpdate, onComplete = _a.onComplete;
    var currentAnimation;
    function isOutOfBounds(v) {
        return (min !== undefined && v < min) || (max !== undefined && v > max);
    }
    function boundaryNearest(v) {
        if (min === undefined)
            return max;
        if (max === undefined)
            return min;
        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
    }
    function startAnimation(options) {
        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
        currentAnimation = animate(__assign$1(__assign$1({}, options), { driver: driver, onUpdate: function (v) {
                var _a;
                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);
            }, onComplete: onComplete }));
    }
    function startSpring(options) {
        startAnimation(__assign$1({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta: restDelta }, options));
    }
    if (isOutOfBounds(from)) {
        startSpring({ from: from, velocity: velocity, to: boundaryNearest(from) });
    }
    else {
        var target = power * velocity + from;
        if (typeof modifyTarget !== "undefined")
            target = modifyTarget(target);
        var boundary_1 = boundaryNearest(target);
        var heading_1 = boundary_1 === min ? -1 : 1;
        var prev_1;
        var current_1;
        var checkBoundary = function (v) {
            prev_1 = current_1;
            current_1 = v;
            velocity = velocityPerSecond(v - prev_1, getFrameData$1().delta);
            if ((heading_1 === 1 && v > boundary_1) ||
                (heading_1 === -1 && v < boundary_1)) {
                startSpring({ from: v, to: boundary_1, velocity: velocity });
            }
        };
        startAnimation({
            type: "decay",
            from: from,
            velocity: velocity,
            timeConstant: timeConstant,
            power: power,
            restDelta: restDelta,
            modifyTarget: modifyTarget,
            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,
        });
    }
    return {
        stop: function () { return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(); },
    };
}

var a = function (a1, a2) { return 1.0 - 3.0 * a2 + 3.0 * a1; };
var b = function (a1, a2) { return 3.0 * a2 - 6.0 * a1; };
var c = function (a1) { return 3.0 * a1; };
var calcBezier = function (t, a1, a2) {
    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};
var getSlope = function (t, a1, a2) {
    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};
var subdivisionPrecision = 0.0000001;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX;
    var currentT;
    var i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (Math.abs(currentX) > subdivisionPrecision &&
        ++i < subdivisionMaxIterations);
    return currentT;
}
var newtonIterations = 8;
var newtonMinSlope = 0.001;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < newtonIterations; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
        return linear;
    var sampleValues = new Float32Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist = (aX - sampleValues[currentSample]) /
            (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= newtonMinSlope) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        }
        else if (initialSlope === 0.0) {
            return guessForT;
        }
        else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function (t) {
        return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
    };
}

/*!
  * @vueuse/motion v1.5.3
  * (c) 2021 
  * @license MIT
  */

const motionState = {};

var defaultTimestep = (1 / 60) * 1000;
var getCurrentTime = typeof performance !== "undefined"
    ? function () { return performance.now(); }
    : function () { return Date.now(); };
var onNextFrame = typeof window !== "undefined"
    ? function (callback) {
        return window.requestAnimationFrame(callback);
    }
    : function (callback) {
        return setTimeout(function () { return callback(getCurrentTime()); }, defaultTimestep);
    };

function createRenderStep(runNextFrame) {
    var toRun = [];
    var toRunNextFrame = [];
    var numToRun = 0;
    var isProcessing = false;
    var toKeepAlive = new WeakSet();
    var step = {
        schedule: function (callback, keepAlive, immediate) {
            if (keepAlive === void 0) { keepAlive = false; }
            if (immediate === void 0) { immediate = false; }
            var addToCurrentFrame = immediate && isProcessing;
            var buffer = addToCurrentFrame ? toRun : toRunNextFrame;
            if (keepAlive)
                toKeepAlive.add(callback);
            if (buffer.indexOf(callback) === -1) {
                buffer.push(callback);
                if (addToCurrentFrame && isProcessing)
                    numToRun = toRun.length;
            }
            return callback;
        },
        cancel: function (callback) {
            var index = toRunNextFrame.indexOf(callback);
            if (index !== -1)
                toRunNextFrame.splice(index, 1);
            toKeepAlive.delete(callback);
        },
        process: function (frameData) {
            var _a;
            isProcessing = true;
            _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];
            toRunNextFrame.length = 0;
            numToRun = toRun.length;
            if (numToRun) {
                for (var i = 0; i < numToRun; i++) {
                    var callback = toRun[i];
                    callback(frameData);
                    if (toKeepAlive.has(callback)) {
                        step.schedule(callback);
                        runNextFrame();
                    }
                }
            }
            isProcessing = false;
        },
    };
    return step;
}

var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
    delta: 0,
    timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];
var steps = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
    acc[key] = createRenderStep(function () {
        return runNextFrame = true;
    });
    return acc;
}, {});
var sync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {
    var step = steps[key];
    acc[key] = function (process, keepAlive, immediate) {
        if (keepAlive === void 0) {
            keepAlive = false;
        }
        if (immediate === void 0) {
            immediate = false;
        }
        if (!runNextFrame) startLoop();
        return step.schedule(process, keepAlive, immediate);
    };
    return acc;
}, {});
var processStep = function (stepId) {
    return steps[stepId].process(frame);
};
var processFrame = function (timestamp) {
    runNextFrame = false;
    frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
    frame.timestamp = timestamp;
    isProcessing = true;
    stepsOrder.forEach(processStep);
    isProcessing = false;
    if (runNextFrame) {
        useDefaultElapsed = false;
        onNextFrame(processFrame);
    }
};
var startLoop = function () {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!isProcessing) onNextFrame(processFrame);
};
var getFrameData = function () {
    return frame;
};

/**
 * A generic subscription manager.
 */
class SubscriptionManager {
    constructor() {
        this.subscriptions = new Set();
    }
    add(handler) {
        this.subscriptions.add(handler);
        return () => void this.subscriptions.delete(handler);
    }
    notify(
    /**
     * Using ...args would be preferable but it's array creation and this
     * might be fired every frame.
     */
    a, b, c) {
        if (!this.subscriptions.size)
            return;
        for (const handler of this.subscriptions) {
            handler(a, b, c);
        }
    }
    clear() {
        this.subscriptions.clear();
    }
}

const isFloat = (value) => {
    return !isNaN(parseFloat(value));
};
/**
 * `MotionValue` is used to track the state and velocity of motion values.
 */
class MotionValue {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     */
    constructor(init) {
        /**
         * Duration, in milliseconds, since last updating frame.
         */
        this.timeDelta = 0;
        /**
         * Timestamp of the last time this `MotionValue` was updated.
         */
        this.lastUpdated = 0;
        /**
         * Functions to notify when the `MotionValue` updates.
         */
        this.updateSubscribers = new SubscriptionManager();
        /**
         * Tracks whether this value can output a velocity.
         */
        this.canTrackVelocity = false;
        /**
         * Update and notify `MotionValue` subscribers.
         *
         * @param v
         * @param render
         */
        this.updateAndNotify = (v) => {
            // Update values
            this.prev = this.current;
            this.current = v;
            // Get frame data
            const { delta, timestamp } = getFrameData();
            // Update timestamp
            if (this.lastUpdated !== timestamp) {
                this.timeDelta = delta;
                this.lastUpdated = timestamp;
            }
            // Schedule velocity check post frame render
            sync.postRender(this.scheduleVelocityCheck);
            // Update subscribers
            this.updateSubscribers.notify(this.current);
        };
        /**
         * Schedule a velocity check for the next frame.
         */
        this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck);
        /**
         * Updates `prev` with `current` if the value hasn't been updated this frame.
         * This ensures velocity calculations return `0`.
         */
        this.velocityCheck = ({ timestamp }) => {
            if (!this.canTrackVelocity)
                this.canTrackVelocity = isFloat(this.current);
            if (timestamp !== this.lastUpdated) {
                this.prev = this.current;
            }
        };
        this.prev = this.current = init;
        this.canTrackVelocity = isFloat(this.current);
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     */
    onChange(subscription) {
        return this.updateSubscribers.add(subscription);
    }
    clearListeners() {
        this.updateSubscribers.clear();
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @param v
     * @param render
     */
    set(v) {
        this.updateAndNotify(v);
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     */
    get() {
        return this.current;
    }
    /**
     * Get previous value.
     *
     * @returns - The previous latest state of `MotionValue`
     */
    getPrevious() {
        return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     */
    getVelocity() {
        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful
        return this.canTrackVelocity
            ? // These casts could be avoided if parseFloat would be typed better
                velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
            : 0;
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     */
    start(animation) {
        this.stop();
        return new Promise((resolve) => {
            const { stop } = animation(resolve);
            this.stopAnimation = stop;
        }).then(() => this.clearAnimation());
    }
    /**
     * Stop the currently active animation.
     */
    stop() {
        if (this.stopAnimation)
            this.stopAnimation();
        this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     */
    isAnimating() {
        return !!this.stopAnimation;
    }
    /**
     * Clear the current animation reference.
     */
    clearAnimation() {
        this.stopAnimation = null;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     */
    destroy() {
        this.updateSubscribers.clear();
        this.stop();
    }
}
function getMotionValue(init) {
    return new MotionValue(init);
}

const { isArray } = Array;
function useMotionValues() {
    const motionValues = {};
    const stop = (keys) => {
        // Destroy key closure
        const destroyKey = (key) => {
            if (!motionValues[key])
                return;
            motionValues[key].stop();
            motionValues[key].destroy();
            vueDemi.del(motionValues, key);
        };
        // Check if keys argument is defined
        if (keys) {
            if (isArray(keys)) {
                // If `keys` are an array, loop on specified keys and destroy them
                keys.forEach(destroyKey);
            }
            else {
                // If `keys` is a string, destroy the specified one
                destroyKey(keys);
            }
        }
        else {
            // No keys specified, destroy all animations
            Object.keys(motionValues).forEach(destroyKey);
        }
    };
    const get = (key, from, target) => {
        if (motionValues[key])
            return motionValues[key];
        // Create motion value
        const motionValue = getMotionValue(from);
        // Set motion properties mapping
        motionValue.onChange((v) => {
            vueDemi.set(target, key, v);
        });
        // Set instance motion value
        vueDemi.set(motionValues, key, motionValue);
        return motionValue;
    };
    // Ensure everything is cleared on unmount
    tryOnUnmounted(stop);
    return {
        motionValues,
        get,
        stop,
    };
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var clamp = function (min, max) { return function (v) {
    return Math.max(Math.min(v, max), min);
}; };
var sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString(v) {
    return typeof v === 'string';
}

var number = {
    test: function (v) { return typeof v === 'number'; },
    parse: parseFloat,
    transform: function (v) { return v; },
};
var alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });
var scale = __assign(__assign({}, number), { default: 1 });

var createUnitType = function (unit) { return ({
    test: function (v) {
        return isString(v) && v.endsWith(unit) && v.split(' ').length === 1;
    },
    parse: parseFloat,
    transform: function (v) { return "" + v + unit; },
}); };
var degrees = createUnitType('deg');
var percent = createUnitType('%');
var px = createUnitType('px');
var progressPercentage = __assign(__assign({}, percent), { parse: function (v) { return percent.parse(v) / 100; }, transform: function (v) { return percent.transform(v * 100); } });

var isColorString = function (type, testProp) { return function (v) {
    return Boolean((isString(v) && singleColorRegex.test(v) && v.startsWith(type)) ||
        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));
}; };
var splitColor = function (aName, bName, cName) { return function (v) {
    var _a;
    if (!isString(v))
        return v;
    var _b = v.match(floatRegex), a = _b[0], b = _b[1], c = _b[2], alpha = _b[3];
    return _a = {},
        _a[aName] = parseFloat(a),
        _a[bName] = parseFloat(b),
        _a[cName] = parseFloat(c),
        _a.alpha = alpha !== undefined ? parseFloat(alpha) : 1,
        _a;
}; };

var hsla = {
    test: isColorString('hsl', 'hue'),
    parse: splitColor('hue', 'saturation', 'lightness'),
    transform: function (_a) {
        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
        return ('hsla(' +
            Math.round(hue) +
            ', ' +
            percent.transform(sanitize(saturation)) +
            ', ' +
            percent.transform(sanitize(lightness)) +
            ', ' +
            sanitize(alpha.transform(alpha$1)) +
            ')');
    },
};

var clampRgbUnit = clamp(0, 255);
var rgbUnit = __assign(__assign({}, number), { transform: function (v) { return Math.round(clampRgbUnit(v)); } });
var rgba = {
    test: isColorString('rgb', 'red'),
    parse: splitColor('red', 'green', 'blue'),
    transform: function (_a) {
        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
        return 'rgba(' +
            rgbUnit.transform(red) +
            ', ' +
            rgbUnit.transform(green) +
            ', ' +
            rgbUnit.transform(blue) +
            ', ' +
            sanitize(alpha.transform(alpha$1)) +
            ')';
    },
};

function parseHex(v) {
    var r = '';
    var g = '';
    var b = '';
    var a = '';
    if (v.length > 5) {
        r = v.substr(1, 2);
        g = v.substr(3, 2);
        b = v.substr(5, 2);
        a = v.substr(7, 2);
    }
    else {
        r = v.substr(1, 1);
        g = v.substr(2, 1);
        b = v.substr(3, 1);
        a = v.substr(4, 1);
        r += r;
        g += g;
        b += b;
        a += a;
    }
    return {
        red: parseInt(r, 16),
        green: parseInt(g, 16),
        blue: parseInt(b, 16),
        alpha: a ? parseInt(a, 16) / 255 : 1,
    };
}
var hex = {
    test: isColorString('#'),
    parse: parseHex,
    transform: rgba.transform,
};

var color = {
    test: function (v) { return rgba.test(v) || hex.test(v) || hsla.test(v); },
    parse: function (v) {
        if (rgba.test(v)) {
            return rgba.parse(v);
        }
        else if (hsla.test(v)) {
            return hsla.parse(v);
        }
        else {
            return hex.parse(v);
        }
    },
    transform: function (v) {
        return isString(v)
            ? v
            : v.hasOwnProperty('red')
                ? rgba.transform(v)
                : hsla.transform(v);
    },
};

var colorToken = '${c}';
var numberToken = '${n}';
function test(v) {
    var _a, _b, _c, _d;
    return (isNaN(v) &&
        isString(v) &&
        ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0);
}
function analyse(v) {
    var values = [];
    var numColors = 0;
    var colors = v.match(colorRegex);
    if (colors) {
        numColors = colors.length;
        v = v.replace(colorRegex, colorToken);
        values.push.apply(values, colors.map(color.parse));
    }
    var numbers = v.match(floatRegex);
    if (numbers) {
        v = v.replace(floatRegex, numberToken);
        values.push.apply(values, numbers.map(number.parse));
    }
    return { values: values, numColors: numColors, tokenised: v };
}
function parse(v) {
    return analyse(v).values;
}
function createTransformer(v) {
    var _a = analyse(v), values = _a.values, numColors = _a.numColors, tokenised = _a.tokenised;
    var numValues = values.length;
    return function (v) {
        var output = tokenised;
        for (var i = 0; i < numValues; i++) {
            output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));
        }
        return output;
    };
}
var convertNumbersToZero = function (v) {
    return typeof v === 'number' ? 0 : v;
};
function getAnimatableNone$1(v) {
    var parsed = parse(v);
    var transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test: test, parse: parse, createTransformer: createTransformer, getAnimatableNone: getAnimatableNone$1 };

var maxDefaults = new Set(['brightness', 'contrast', 'saturate', 'opacity']);
function applyDefaultFilter(v) {
    var _a = v.slice(0, -1).split('('), name = _a[0], value = _a[1];
    if (name === 'drop-shadow')
        return v;
    var number = (value.match(floatRegex) || [])[0];
    if (!number)
        return v;
    var unit = value.replace(number, '');
    var defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number !== value)
        defaultValue *= 100;
    return name + '(' + defaultValue + unit + ')';
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = __assign(__assign({}, complex), { getAnimatableNone: function (v) {
        var functions = v.match(functionRegex);
        return functions ? functions.map(applyDefaultFilter).join(' ') : v;
    } });

const isKeyframesTarget = (v) => {
    return Array.isArray(v);
};
const underDampedSpring = () => ({
    type: 'spring',
    stiffness: 500,
    damping: 25,
    restDelta: 0.5,
    restSpeed: 10,
});
const criticallyDampedSpring = (to) => ({
    type: 'spring',
    stiffness: 550,
    damping: to === 0 ? 2 * Math.sqrt(550) : 30,
    restDelta: 0.01,
    restSpeed: 10,
});
const overDampedSpring = (to) => ({
    type: 'spring',
    stiffness: 550,
    damping: to === 0 ? 100 : 30,
    restDelta: 0.01,
    restSpeed: 10,
});
const linearTween = () => ({
    type: 'keyframes',
    ease: 'linear',
    duration: 300,
});
const keyframes = (values) => ({
    type: 'keyframes',
    duration: 800,
    values,
});
const defaultTransitions = {
    default: overDampedSpring,
    x: underDampedSpring,
    y: underDampedSpring,
    z: underDampedSpring,
    rotate: underDampedSpring,
    rotateX: underDampedSpring,
    rotateY: underDampedSpring,
    rotateZ: underDampedSpring,
    scaleX: criticallyDampedSpring,
    scaleY: criticallyDampedSpring,
    scale: criticallyDampedSpring,
    backgroundColor: linearTween,
    color: linearTween,
    opacity: linearTween,
};
const getDefaultTransition = (valueKey, to) => {
    let transitionFactory;
    if (isKeyframesTarget(to)) {
        transitionFactory = keyframes;
    }
    else {
        transitionFactory =
            defaultTransitions[valueKey] || defaultTransitions.default;
    }
    return { to, ...transitionFactory(to) };
};

/**
 * ValueType for ints
 */
const int = {
    ...number,
    transform: Math.round,
};
const valueTypes = {
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    size: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Transform props
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
    // Misc
    zIndex: int,
    filter,
    WebkitFilter: filter,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int,
};
/**
 * Return the value type for a key.
 *
 * @param key
 */
const getValueType = (key) => valueTypes[key];
/**
 * Transform the value using its value type, or return the value.
 *
 * @param value
 * @param type
 */
const getValueAsType = (value, type) => {
    return type && typeof value === 'number' && type.transform
        ? type.transform(value)
        : value;
};
/**
 * Get default animatable
 *
 * @param key
 * @param value
 */
function getAnimatableNone(key, value) {
    let defaultValueType = getValueType(key);
    if (defaultValueType !== filter)
        defaultValueType = complex;
    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
    return defaultValueType.getAnimatableNone
        ? defaultValueType.getAnimatableNone(value)
        : undefined;
}

// Easing map from popmotion
const easingLookup = {
    linear,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate,
    bounceIn,
    bounceInOut,
    bounceOut,
};
/**
 * Transform easing definition to easing function.
 *
 * @param definition
 */
const easingDefinitionToFunction = (definition) => {
    if (Array.isArray(definition)) {
        const [x1, y1, x2, y2] = definition;
        return cubicBezier(x1, y1, x2, y2);
    }
    else if (typeof definition === 'string') {
        return easingLookup[definition];
    }
    return definition;
};
/**
 * Create an easing array
 *
 * @param ease
 */
const isEasingArray = (ease) => {
    return Array.isArray(ease) && typeof ease[0] !== 'number';
};
/**
 * Check if a value is animatable. Examples:
 *
 * ✅: 100, "100px", "#fff"
 * ❌: "block", "url(2.jpg)"
 * @param value
 *
 * @internal
 */
const isAnimatable = (key, value) => {
    // If the list of keys tat might be non-animatable grows, replace with Set
    if (key === 'zIndex')
        return false;
    // If it's a number or a keyframes array, we can animate it. We might at some point
    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
    // but for now lets leave it like this for performance reasons
    if (typeof value === 'number' || Array.isArray(value))
        return true;
    if (typeof value === 'string' && // It's animatable if we have a string
        complex.test(value) && // And it contains numbers and/or colors
        !value.startsWith('url(') // Unless it starts with "url("
    ) {
        return true;
    }
    return false;
};
/**
 * Hydrate keyframes from transition options.
 *
 * @param options
 */
function hydrateKeyframes(options) {
    if (Array.isArray(options.to) && options.to[0] === null) {
        options.to = [...options.to];
        options.to[0] = options.from;
    }
    return options;
}
/**
 * Convert Transition type into Popmotion-compatible options.
 */
function convertTransitionToAnimationOptions({ ease, times, delay, ...transition }) {
    const options = { ...transition };
    if (times)
        options['offset'] = times;
    // Map easing names to Popmotion's easing functions
    if (ease) {
        options['ease'] = isEasingArray(ease)
            ? ease.map(easingDefinitionToFunction)
            : easingDefinitionToFunction(ease);
    }
    // Map delay to elapsed from Popmotion
    if (delay) {
        options['elapsed'] = -delay;
    }
    return options;
}
/**
 * Get PopMotion animation options from Transition definition
 *
 * @param transition
 * @param options
 * @param key
 */
function getPopmotionAnimationOptions(transition, options, key) {
    if (Array.isArray(options.to)) {
        if (!transition.duration)
            transition.duration = 800;
    }
    hydrateKeyframes(options);
    // Get a default transition if none is determined to be defined.
    if (!isTransitionDefined(transition)) {
        transition = {
            ...transition,
            ...getDefaultTransition(key, options.to),
        };
    }
    return {
        ...options,
        ...convertTransitionToAnimationOptions(transition),
    };
}
/**
 * Decide whether a transition is defined on a given Transition.
 * This filters out orchestration options and returns true
 * if any options are left.
 */
function isTransitionDefined({ delay, repeat, repeatType, repeatDelay, from, ...transition }) {
    return !!Object.keys(transition).length;
}
/**
 * Get the transition definition for the current value.
 *
 * First search for transition nested definition (key or default),
 * then fallback on the main transition definition itself.
 *
 * @param transition
 * @param key
 */
function getValueTransition(transition, key) {
    return transition[key] || transition['default'] || transition;
}
/**
 * Get the animation function populated with variant values.
 */
function getAnimation(key, value, target, transition, onComplete) {
    // Get key transition or fallback values
    const valueTransition = getValueTransition(transition, key);
    // Get origin
    let origin = valueTransition.from === null || valueTransition.from === undefined
        ? value.get()
        : valueTransition.from;
    // Is target animatable
    const isTargetAnimatable = isAnimatable(key, target);
    // If we're trying to animate from "none", try and get an animatable version
    // of the target. This could be improved to work both ways.
    if (origin === 'none' && isTargetAnimatable && typeof target === 'string') {
        origin = getAnimatableNone(key, target);
    }
    // Is origin animatable
    const isOriginAnimatable = isAnimatable(key, origin);
    /**
     * Start the animation.
     */
    function start(complete) {
        const options = {
            from: origin,
            to: target,
            velocity: transition.velocity ? transition.velocity : value.getVelocity(),
            onUpdate: (v) => value.set(v),
        };
        return valueTransition.type === 'inertia' ||
            valueTransition.type === 'decay'
            ? inertia({ ...options, ...valueTransition })
            : animate({
                ...getPopmotionAnimationOptions(valueTransition, options, key),
                onUpdate: (v) => {
                    options.onUpdate(v);
                    if (valueTransition.onUpdate)
                        valueTransition.onUpdate(v);
                },
                onComplete: () => {
                    if (transition.onComplete)
                        transition.onComplete();
                    if (onComplete)
                        onComplete();
                    if (complete)
                        complete();
                },
            });
    }
    /**
     * Set value without transition.
     */
    function set(complete) {
        value.set(target);
        if (transition.onComplete)
            transition.onComplete();
        if (onComplete)
            onComplete();
        if (complete)
            complete();
        return { stop: () => { } };
    }
    return !isOriginAnimatable ||
        !isTargetAnimatable ||
        valueTransition.type === false
        ? set
        : start;
}

/**
 * A Composable holding all the ongoing transitions in a local reference.
 */
function useMotionTransitions() {
    const { motionValues, stop, get } = useMotionValues();
    const push = (key, value, target, transition = {}, onComplete) => {
        // Get the `from` key from target
        const from = target[key];
        // Get motion value for the target key
        const motionValue = get(key, from, target);
        // Sets the value immediately if specified
        if (transition && transition.immediate) {
            motionValue.set(value);
            return;
        }
        // Create animation
        const animation = getAnimation(key, motionValue, value, transition, onComplete);
        // Start animation
        motionValue.start(animation);
    };
    return { motionValues, stop, push };
}

/**
 * A Composable handling motion controls, pushing resolved variant to useMotionTransitions manager.
 *
 * @param transform
 * @param style
 * @param currentVariant
 */
function useMotionControls(motionProperties, variants = {}, { push, stop } = useMotionTransitions()) {
    // Variants as ref
    const _variants = vueDemi.unref(variants);
    const getVariantFromKey = (variant) => {
        if (!_variants || !_variants[variant]) {
            throw new Error(`The variant ${variant} does not exist.`);
        }
        return _variants[variant];
    };
    const apply = (variant) => {
        // If variant is a key, try to resolve it
        if (typeof variant === 'string') {
            variant = getVariantFromKey(variant);
        }
        // Return Promise chain
        return Promise.all(Object.entries(variant).map(([key, value]) => {
            // Skip transition key
            if (key === 'transition')
                return;
            return new Promise((resolve) => {
                push(key, value, motionProperties, variant.transition ||
                    getDefaultTransition(key, variant[key]), resolve);
            });
        }));
    };
    const set = (variant) => {
        // Get variant data from parameter
        let variantData = isObject(variant) ? variant : getVariantFromKey(variant);
        // Set in chain
        Object.entries(variantData).forEach(([key, value]) => {
            // Skip transition key
            if (key === 'transition')
                return;
            push(key, value, motionProperties, {
                immediate: true,
            });
        });
    };
    const leave = async (done) => {
        let leaveVariant;
        if (_variants) {
            if (_variants.leave) {
                leaveVariant = _variants.leave;
            }
            if (!_variants.leave && _variants.initial) {
                leaveVariant = _variants.initial;
            }
        }
        if (!leaveVariant) {
            done();
            return;
        }
        await apply(leaveVariant);
        done();
    };
    return {
        apply,
        set,
        stopTransitions: stop,
        leave,
    };
}

const isBrowser = typeof window !== 'undefined';
const supportsPointerEvents = () => isBrowser && window.onpointerdown === null;
const supportsTouchEvents = () => isBrowser && window.ontouchstart === null;
const supportsMouseEvents = () => isBrowser && window.onmousedown === null;

function registerEventListeners({ target, state, variants, apply, }) {
    const _variants = vueDemi.unref(variants);
    // State
    const hovered = vueDemi.ref(false);
    const tapped = vueDemi.ref(false);
    const focused = vueDemi.ref(false);
    const mutableKeys = vueDemi.computed(() => {
        let result = [];
        if (!_variants)
            return result;
        if (_variants.hovered) {
            result = [...result, ...Object.keys(_variants.hovered)];
        }
        if (_variants.tapped) {
            result = [...result, ...Object.keys(_variants.tapped)];
        }
        if (_variants.focused) {
            result = [...result, ...Object.keys(_variants.focused)];
        }
        return result;
    });
    const computedProperties = vueDemi.computed(() => {
        const result = {};
        Object.assign(result, state.value);
        if (hovered.value && _variants.hovered) {
            Object.assign(result, _variants.hovered);
        }
        if (tapped.value && _variants.tapped) {
            Object.assign(result, _variants.tapped);
        }
        if (focused.value && _variants.focused) {
            Object.assign(result, _variants.focused);
        }
        for (const key in result) {
            if (!mutableKeys.value.includes(key))
                delete result[key];
        }
        return result;
    });
    vueDemi.watch(() => unrefElement(target), (el) => {
        if (!el || !_variants)
            return;
        // Hovered
        if (_variants.hovered) {
            useEventListener(el, 'mouseenter', () => {
                hovered.value = true;
            });
            useEventListener(el, 'mouseleave', () => {
                hovered.value = false;
                tapped.value = false;
            });
            useEventListener(el, 'mouseout', () => {
                hovered.value = false;
                tapped.value = false;
            });
        }
        // Tapped
        if (_variants.tapped) {
            // Mouse
            if (supportsMouseEvents()) {
                useEventListener(el, 'mousedown', () => {
                    tapped.value = true;
                });
                useEventListener(el, 'mouseup', () => {
                    tapped.value = false;
                });
            }
            // Pointer
            if (supportsPointerEvents()) {
                useEventListener(el, 'pointerdown', () => {
                    tapped.value = true;
                });
                useEventListener(el, 'pointerup', () => {
                    tapped.value = false;
                });
            }
            // Touch
            if (supportsTouchEvents()) {
                useEventListener(el, 'touchstart', () => {
                    tapped.value = true;
                });
                useEventListener(el, 'touchend', () => {
                    tapped.value = false;
                });
            }
        }
        // Focused
        if (_variants.focused) {
            useEventListener(el, 'focus', () => {
                focused.value = true;
            });
            useEventListener(el, 'blur', () => {
                focused.value = false;
            });
        }
    }, {
        immediate: true,
    });
    // Watch local computed variant, apply it dynamically
    vueDemi.watch(computedProperties, (newVal) => {
        apply(newVal);
    });
}

function registerLifeCycleHooks({ target, variants, variant, }) {
    const _variants = vueDemi.unref(variants);
    const stop = vueDemi.watch(() => target, () => {
        // Lifecycle hooks bindings
        if (_variants && _variants.enter) {
            // Set initial before the element is mounted
            if (_variants.initial)
                variant.value = 'initial';
            // Set enter animation, once the element is mounted
            vueDemi.nextTick(() => (variant.value = 'enter'));
        }
    }, {
        immediate: true,
        flush: 'pre',
    });
    return { stop };
}

function registerVariantsSync({ state, apply, }) {
    // Watch for variant changes and apply the new one
    const stop = vueDemi.watch(state, (newVal) => {
        if (newVal)
            apply(newVal);
    }, {
        immediate: true,
    });
    return { stop };
}

function registerVisibilityHooks({ target, variants, variant, }) {
    const _variants = vueDemi.unref(variants);
    let _stopObserver = noop;
    const _stopWatcher = vueDemi.watch(() => unrefElement(target), (el) => {
        if (!el)
            return;
        // Bind intersection observer on target
        _stopObserver = useIntersectionObserver(target, ([{ isIntersecting }]) => {
            if (_variants && _variants.visible) {
                if (isIntersecting) {
                    variant.value = 'visible';
                }
                else {
                    variant.value = 'initial';
                }
            }
        }).stop;
    }, {
        immediate: true,
    });
    /**
     * Stop both the watcher and the intersection observer.
     */
    const stop = () => {
        _stopObserver();
        _stopWatcher();
    };
    return {
        stop,
    };
}

/**
 * A Composable executing resolved variants features from variants declarations.
 *
 * Supports:
 * - lifeCycleHooks: Bind the motion hooks to the component lifecycle hooks.
 *
 * @param variant
 * @param variants
 * @param options
 */
function useMotionFeatures(instance, options = {
    syncVariants: true,
    lifeCycleHooks: true,
    visibilityHooks: true,
    eventListeners: true,
}) {
    // Lifecycle hooks bindings
    if (options.lifeCycleHooks) {
        registerLifeCycleHooks(instance);
    }
    if (options.syncVariants) {
        registerVariantsSync(instance);
    }
    // Visibility hooks
    if (options.visibilityHooks) {
        registerVisibilityHooks(instance);
    }
    // Event listeners
    if (options.eventListeners) {
        registerEventListeners(instance);
    }
}

/**
 * Reactive style object implementing all native CSS properties.
 *
 * @param props
 */
function reactiveStyle(props = {}) {
    // Reactive StyleProperties object
    const state = vueDemi.reactive({
        ...props,
    });
    const style = vueDemi.ref({});
    // Reactive DOM Element compatible `style` object bound to state
    vueDemi.watch(state, () => {
        // Init result object
        const result = {};
        for (const [key, value] of Object.entries(state)) {
            // Get value type for key
            const valueType = getValueType(key);
            // Get value as type for key
            const valueAsType = getValueAsType(value, valueType);
            // Append the computed style to result object
            result[key] = valueAsType;
        }
        style.value = result;
    }, {
        immediate: true,
        deep: true,
    });
    return {
        state,
        style,
    };
}

/**
 * A list of all transformable axes. We'll use this list to generated a version
 * of each axes for each transform.
 */
const transformAxes = ['', 'X', 'Y', 'Z'];
/**
 * An ordered array of each transformable value. By default, transform values
 * will be sorted to this order.
 */
const order = ['perspective', 'translate', 'scale', 'rotate', 'skew'];
/**
 * Generate a list of every possible transform key.
 */
const transformProps = ['transformPerspective', 'x', 'y', 'z'];
order.forEach((operationKey) => {
    transformAxes.forEach((axesKey) => {
        const key = operationKey + axesKey;
        transformProps.push(key);
    });
});
/**
 * A quick lookup for transform props.
 */
const transformPropSet = new Set(transformProps);
function isTransformProp(key) {
    return transformPropSet.has(key);
}
/**
 * A quick lookup for transform origin props
 */
const transformOriginProps = new Set(['originX', 'originY', 'originZ']);
function isTransformOriginProp(key) {
    return transformOriginProps.has(key);
}

/**
 * A Composable giving access to a StyleProperties object, and binding the generated style object to a target.
 *
 * @param target
 */
function useElementStyle(target, onInit) {
    // Transform cache available before the element is mounted
    let _cache;
    // Local target cache as we need to resolve the element from PermissiveTarget
    let _target = undefined;
    // Create a reactive style object
    const { state, style } = reactiveStyle();
    // Sync existing style from supplied element
    const stopInitWatch = vueDemi.watch(() => unrefElement(target), (el) => {
        if (!el)
            return;
        _target = el;
        // Loop on style keys
        for (const key of Object.keys(valueTypes)) {
            if (el.style[key] === null ||
                el.style[key] === '' ||
                isTransformProp(key) ||
                isTransformOriginProp(key))
                continue;
            // Append a defined key to the local StyleProperties state object
            vueDemi.set(state, key, el.style[key]);
        }
        // If cache is present, init the target with the current cached value
        if (_cache) {
            Object.entries(_cache).forEach(([key, value]) => vueDemi.set(el.style, key, value));
        }
        if (onInit)
            onInit(state);
    }, {
        immediate: true,
    });
    // Sync reactive style to element
    const stopSyncWatch = vueDemi.watch(style, (newVal) => {
        // Add the current value to the cache so it is set on target creation
        if (!_target) {
            _cache = newVal;
            return;
        }
        // Append the state object to the target style properties
        for (const key in newVal)
            vueDemi.set(_target.style, key, newVal[key]);
    }, {
        immediate: true,
    });
    // Stop watchers
    const stop = () => {
        stopInitWatch();
        stopSyncWatch();
    };
    return {
        style: state,
        stop,
    };
}

/**
 * Aliases translate key for simpler API integration.
 */
const translateAlias = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
};
/**
 * Reactive transform string implementing all native CSS transform properties.
 *
 * @param props
 * @param enableHardwareAcceleration
 */
function reactiveTransform(props = {}, enableHardwareAcceleration = true) {
    // Reactive TransformProperties object
    const state = vueDemi.reactive({ ...props });
    const transform = vueDemi.ref('');
    vueDemi.watch(state, (newVal) => {
        // Init result
        let result = '';
        let hasHardwareAcceleration = false;
        // Use translate3d by default has a better GPU optimization
        // And corrects scaling discrete behaviors
        if (enableHardwareAcceleration && (newVal.x || newVal.y || newVal.z)) {
            const str = [newVal.x || 0, newVal.y || 0, newVal.z || 0]
                .map(px.transform)
                .join(',');
            result += `translate3d(${str}) `;
            hasHardwareAcceleration = true;
        }
        // Loop on defined TransformProperties state keys
        for (const [key, value] of Object.entries(newVal)) {
            if (enableHardwareAcceleration &&
                (key === 'x' || key === 'y' || key === 'z'))
                continue;
            // Get value type for key
            const valueType = getValueType(key);
            // Get value as type for key
            const valueAsType = getValueAsType(value, valueType);
            // Append the computed transform key to result string
            result += `${translateAlias[key] || key}(${valueAsType}) `;
        }
        if (enableHardwareAcceleration && !hasHardwareAcceleration) {
            result += `translateZ(0px) `;
        }
        transform.value = result.trim();
    }, {
        immediate: true,
        deep: true,
    });
    return {
        state,
        transform,
    };
}

/**
 * Return an object from a transform string.
 *
 * @param str
 */
function parseTransform(transform) {
    // Split transform string.
    const transforms = transform.trim().split(/\) |\)/);
    // Handle "initial", "inherit", "unset".
    if (transforms.length === 1) {
        return {};
    }
    const parseValues = (value) => {
        // If value is ending with px or deg, return it as a number
        if (value.endsWith('px') || value.endsWith('deg'))
            return parseFloat(value);
        // Return as number
        if (isNaN(Number(value)))
            return Number(value);
        // Parsing impossible, return as string
        return value;
    };
    // Reduce the result to an object and return it
    return transforms.reduce((acc, transform) => {
        if (!transform)
            return acc;
        const [name, transformValue] = transform.split('(');
        const valueArray = transformValue.split(',');
        const values = valueArray.map((val) => {
            return parseValues(val.endsWith(')') ? val.replace(')', '') : val.trim());
        });
        const value = values.length === 1 ? values[0] : values;
        return {
            ...acc,
            [name]: value,
        };
    }, {});
}
/**
 * Sets the state from a parsed transform string.
 *
 * Used in useElementTransform init to restore element transform string in cases it does exists.
 *
 * @param state
 * @param transform
 */
function stateFromTransform(state, transform) {
    Object.entries(parseTransform(transform)).forEach(([key, value]) => {
        // Get value w/o unit, as unit is applied later on
        value = parseFloat(value);
        // Axes reference for loops
        const axes = ['x', 'y', 'z'];
        // Handle translate3d and scale3d
        if (key === 'translate3d') {
            // Loop on parsed scale / translate definition
            value.forEach((axisValue, index) => {
                vueDemi.set(state, axes[index], axisValue);
            });
            return;
        }
        // Sync translateX on X
        if (key === 'translateX') {
            vueDemi.set(state, 'x', value);
            return;
        }
        // Sync translateY on Y
        if (key === 'translateY') {
            vueDemi.set(state, 'y', value);
            return;
        }
        // Sync translateZ on Z
        if (key === 'translateZ') {
            vueDemi.set(state, 'z', value);
            return;
        }
        // Set raw value
        vueDemi.set(state, key, value);
    });
}

/**
 * A Composable giving access to a TransformProperties object, and binding the generated transform string to a target.
 *
 * @param target
 */
function useElementTransform(target, onInit) {
    // Transform cache available before the element is mounted
    let _cache;
    // Local target cache as we need to resolve the element from PermissiveTarget
    let _target = undefined;
    // Create a reactive transform object
    const { state, transform } = reactiveTransform();
    // Cache transform until the element is alive and we can bind to it
    const stopInitWatch = vueDemi.watch(() => unrefElement(target), (el) => {
        if (!el)
            return;
        _target = el;
        // Parse transform properties and applies them to the current state
        if (el.style.transform)
            stateFromTransform(state, el.style.transform);
        // If cache is present, init the target with the current cached value
        if (_cache) {
            el.style.transform = _cache;
        }
        if (onInit)
            onInit(state);
    }, {
        immediate: true,
    });
    // Sync reactive transform to element
    const stopSyncWatch = vueDemi.watch(transform, (newValue) => {
        // Add the current value to the cache so it is set on target creation
        if (!_target) {
            _cache = newValue;
            return;
        }
        // Set the transform string on the target
        _target.style.transform = newValue;
    }, {
        immediate: true,
    });
    // Stop watchers
    const stop = () => {
        stopInitWatch();
        stopSyncWatch();
    };
    return {
        transform: state,
        stop,
    };
}

/**
 * A Composable giving access to both `transform` and `style`objects for a single element.
 *
 * @param target
 */
function useMotionProperties(target, defaultValues) {
    // Local motion properties
    const motionProperties = vueDemi.reactive({});
    // Local mass setter
    const apply = (values) => {
        Object.entries(values).forEach(([key, value]) => {
            vueDemi.set(motionProperties, key, value);
        });
    };
    // Target element style object
    const { style, stop: stopStyleWatchers } = useElementStyle(target, apply);
    // Target element transform object
    const { transform, stop: stopTransformWatchers } = useElementTransform(target, apply);
    // Watch local object and apply styling accordingly
    const stopPropertiesWatch = vueDemi.watch(motionProperties, (newVal) => {
        Object.entries(newVal).forEach(([key, value]) => {
            const target = isTransformProp(key) ? transform : style;
            if (target[key] && target[key] === value)
                return;
            vueDemi.set(target, key, value);
        });
    }, {
        immediate: true,
        deep: true,
    });
    // Apply default values once target is available
    const stopInitWatch = vueDemi.watch(() => unrefElement(target), (el) => {
        if (!el)
            return;
        if (defaultValues)
            apply(defaultValues);
    }, {
        immediate: true,
    });
    // Stop watchers
    const stop = () => {
        stopStyleWatchers();
        stopTransformWatchers();
        stopPropertiesWatch();
        stopInitWatch();
    };
    return {
        motionProperties,
        style,
        transform,
        stop,
    };
}

/**
 * A Composable handling variants selection and features.
 *
 * @param variants
 * @param initial
 * @param options
 */
function useMotionVariants(variants = {}) {
    // Unref variants
    const _variants = vueDemi.unref(variants);
    // Current variant string
    const variant = vueDemi.ref();
    // Current variant state
    const state = vueDemi.computed(() => {
        if (!variant.value)
            return undefined;
        return _variants[variant.value];
    });
    return {
        state,
        variant,
    };
}

/**
 * A Vue Composable that put your components in motion.
 *
 * @docs https://motion.vueuse.js.org
 *
 * @param target
 * @param variants
 * @param options
 */
function useMotion(target, variants = {}, options) {
    // Reactive styling and transform
    const { motionProperties } = useMotionProperties(target);
    // Variants manager
    const { variant, state } = useMotionVariants(variants);
    // Motion controls, synchronized with motion properties and variants
    const controls = useMotionControls(motionProperties, variants);
    // Create motion instance
    const instance = {
        target,
        variant,
        variants,
        state,
        motionProperties,
        ...controls,
    };
    // Bind features
    useMotionFeatures(instance, options);
    return instance;
}

const directivePropsKeys = [
    'initial',
    'enter',
    'leave',
    'visible',
    'hovered',
    'tapped',
    'focused',
    'delay',
];
const resolveVariants = (node, variantsRef) => {
    // This is done to achieve compat with Vue 2 & 3
    // node.props = Vue 3 element props location
    // node.data.attrs = Vue 2 element props location
    const target = node.props
        ? node.props // @ts-expect-error
        : node.data && node.data.attrs // @ts-expect-error
            ? node.data.attrs
            : {};
    if (target) {
        if (target['variants'] && isObject(target['variants'])) {
            // If variant are passed through a single object reference, initialize with it
            variantsRef.value = {
                ...variantsRef.value,
                ...target['variants'],
            };
        }
        // Loop on directive prop keys, add them to the local variantsRef if defined
        directivePropsKeys.forEach((key) => {
            if (key === 'delay') {
                if (target && target[key] && isNumber(target[key])) {
                    const delay = target[key];
                    if (variantsRef && variantsRef.value) {
                        if (variantsRef.value.enter) {
                            if (!variantsRef.value.enter.transition) {
                                variantsRef.value.enter.transition = {};
                            }
                            variantsRef.value.enter.transition = {
                                ...variantsRef.value.enter.transition,
                                delay,
                            };
                        }
                        if (variantsRef.value.visible) {
                            if (!variantsRef.value.visible.transition) {
                                variantsRef.value.visible.transition = {};
                            }
                            variantsRef.value.visible.transition = {
                                ...variantsRef.value.visible.transition,
                                delay,
                            };
                        }
                    }
                }
                return;
            }
            if (target && target[key] && isObject(target[key])) {
                variantsRef.value[key] = target[key];
            }
        });
    }
};

const directive = (variants) => {
    const register = (el, binding, node) => {
        // Initialize variants with argument
        const variantsRef = vueDemi.ref(variants || {});
        // Resolve variants from node props
        resolveVariants(node, variantsRef);
        // Create motion instance
        const motionInstance = useMotion(el, variantsRef);
        // Set the global state reference if the name is set through v-motion="`value`"
        if (binding.value)
            vueDemi.set(motionState, binding.value, motionInstance);
    };
    const unregister = (el, binding, node) => {
        // Check if motion state has the current element as reference
        if (binding.value && motionState[binding.value])
            vueDemi.del(motionState, binding.value);
    };
    return {
        // Vue 3 Directive Hooks
        created: register,
        unmounted: unregister,
        // Vue 2 Directive Hooks
        // For Nuxt & Vue 2 compatibility
        // @ts-expect-error
        bind: register,
        unbind: unregister,
    };
};

function useMotions() {
    return motionState;
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "dl,\nol,\nul {\n  margin-bottom: 0;\n  margin-block-start: 0;\n  margin-inline-start: 0;\n  margin-inline-end: 0;\n  padding-inline-start: 0;\n  list-style-type: none;\n}\n\n#vue-my-toasts-root {\n  max-width: var(--vueMyToastsWidth);\n  width: var(--vueMyToastsWidth);\n  padding: var(--vueMyToastsPadding);\n  position: fixed;\n  z-index: 999999;\n}\n\n.vue-my-toasts-wrapper {\n  width: 100%;\n  display: flex;\n  align-items: stretch;\n  justify-content: stretch;\n}\n\n.vue-my-toasts-full {\n  width: 100% !important;\n}\n\n.vue-my-toasts-wrapper-top-right,\n.vue-my-toasts-wrapper-top-left,\n.vue-my-toasts-wrapper-top-middle {\n  flex-direction: column;\n}\n\n.vue-my-toasts-wrapper-bottom-right,\n.vue-my-toasts-wrapper-bottom-left,\n.vue-my-toasts-wrapper-bottom-middle {\n  flex-direction: column-reverse;\n}\n\n.vue-my-toasts-bottom-right {\n  bottom: 0;\n  right: 0;\n}\n\n.vue-my-toasts-bottom-left {\n  bottom: 0;\n  left: 0;\n}\n\n.vue-my-toasts-bottom-left {\n  bottom: 0;\n  left: 0;\n}\n\n.vue-my-toasts-top-right {\n  top: 0;\n  right: 0;\n}\n\n.vue-my-toasts-top-left {\n  top: 0;\n  left: 0;\n}\n\n.vue-my-toasts-top-middle {\n  top: 0;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.vue-my-toasts-bottom-middle {\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n}\n";
styleInject(css_248z);

const defaultVariants = (position) => {
    return {
        initial: {
            y: position.includes('bottom') ? 50 : -50,
            opacity: 0,
            scale: 1,
        },
        enter: { y: 0, opacity: 1, scale: 1 },
        leave: { scale: 0, opacity: 0, height: 0 },
    };
};
var MyToasts = vueDemi.defineComponent({
    name: 'MyToasts',
    props: {
        padding: {
            type: String,
            required: false,
            default: '1rem',
        },
        width: {
            type: String,
            required: false,
            default: '400px',
        },
        position: {
            type: String,
            required: false,
            default: 'bottom-right',
        },
        component: {
            type: Object,
            required: true,
        },
        variants: {
            type: [Object, Function],
            required: false,
            default: ({ position }) => defaultVariants(position),
        },
    },
    setup(props) {
        const leaving = vueDemi.ref(false);
        const full = vueDemi.ref(false);
        const toasts = vueDemi.ref([]);
        // Handle
        const handleResize = () => {
            if (parseInt(props.width) > window.innerWidth) {
                full.value = true;
            }
        };
        vueDemi.onBeforeMount(() => {
            window.addEventListener('resize', handleResize);
            handleResize();
        });
        vueDemi.onBeforeUnmount(() => window.removeEventListener('resize', handleResize));
        /**
         * Add toast to instance
         *
         * @param toast
         */
        const add = (toast) => {
            // Push the toast data to the toasts list
            toasts.value.push(toast);
        };
        /**
         * Remove toast from instance
         *
         * @param toastId
         */
        const remove = (toastId = undefined) => {
            leaving.value = true;
            // Break if there is no toast to delete
            if (toasts.value.length === 0)
                return;
            // Get last toast id if no toastId is provided
            toastId = toastId || toasts.value[0].id;
            // Filter the toasts
            toasts.value = toasts.value.filter((toast) => toast.id !== toastId);
        };
        const leave = (el, done) => {
            leaving.value = true;
            const motions = useMotions();
            const { height } = el.getBoundingClientRect();
            const instance = motions[el.dataset.id];
            instance.set({
                height,
            });
            instance.leave(() => {
                leaving.value = false;
                done();
            });
        };
        /**
         * Get the animation variants for a toast
         *
         * @param position
         * @param toastId
         * @param index
         * @returns MotionVariants
         */
        const toastVariants = (position, toastId, index) => {
            let animations = {
                ...defaultVariants(position),
            };
            if (typeof props.variants === 'function') {
                animations = {
                    ...animations,
                    ...props.variants(position, toastId, index),
                };
            }
            if (typeof props.variants === 'object') {
                animations = { ...animations, ...props.variants };
            }
            return animations;
        };
        return {
            toastVariants,
            leaving,
            toasts,
            add,
            remove,
            leave,
            full,
        };
    },
    render({ full, position, width, padding, toasts, leaving, leave, toastVariants, component, remove, }) {
        return vueDemi.h('div', {
            id: 'vue-my-toasts-root',
            class: [
                'vue-my-toasts',
                `vue-my-toasts-${position}`,
                { 'vue-my-toasts-full': full },
            ],
            style: {
                '--vueMyToastsWidth': width,
                '--vueMyToastsPadding': padding,
                display: toasts.length > 0 || leaving ? 'block' : 'none',
            },
        }, [
            vueDemi.h(vueDemi.TransitionGroup, {
                css: false,
                onLeave: leave,
                tag: 'ul',
                class: [
                    'vue-my-toasts-wrapper',
                    `vue-my-toasts-wrapper-${position}`,
                ],
            }, () => toasts.map((toast, index) => vueDemi.withDirectives(vueDemi.h('li', {
                key: toast.id,
                'data-id': toast.id,
            }, [
                vueDemi.h(component, {
                    class: [`vue-my-toasts-${position}`],
                    index,
                    position,
                    full,
                    onRemove: () => remove(toast.id),
                    ...toast,
                }),
            ]), [
                [
                    directive(toastVariants(position, toast.id, index)),
                    toast.id,
                ],
            ]))),
        ]);
    },
});

/**
 * Register toast handler component to root
 * @param pluginOptions
 * @returns {{reference: Vue | object | Record<never, any>, instance: Vue}}
 */
var injectComponent = (pluginOptions, userComponent) => {
    // inject userComponent to the pluginOptions
    const _props = { ...pluginOptions, component: userComponent };
    // Create root element
    const rootEl = document.createElement('div');
    // Set root element id
    rootEl.id = 'vue-my-toasts';
    // Append component to body
    document.body.appendChild(rootEl);
    // Create toasts layer instance
    const vueInstance = vueDemi.createApp(MyToasts, _props);
    // Create component
    const vueComponent = vueInstance.mount('#vue-my-toasts');
    // Return created instances
    return {
        reference: vueInstance,
        instance: vueComponent,
    };
};

// -- Main plugin reference
// eslint-disable-next-line no-unused-vars
let reference = null;
// -- Main plugin instance
let instance = null;
// -- Shallow reference for instance toasts
let toasts = vueDemi.ref([]);
/**
 * Add a new toast to the instance
 *
 * @param toast
 */
const push = (toast) => {
    // Check if instance exists
    if (!instance)
        return;
    // Check if toast id is specified
    if (!toast.id)
        toast.id = getUuid();
    // Add toast
    instance.add(toast);
};
/**
 * Remove a toast from the instance
 *
 * @param toastId
 */
const remove = (toastId) => {
    // Check if instance exists
    if (!instance)
        return;
    // Check if toastId is specified
    if (!toastId) {
        console.warn('You need to provide a toastId to remove a toast programatically.');
        return;
    }
    // Remove toast from component
    instance.remove(toastId);
};
/**
 * Update the plugin config
 */
const updateConfig$1 = (pluginOptions, component) => {
    // Remove present root element
    const rootEl = document.querySelector('#vue-my-toasts');
    // Unmount current instance
    if (reference)
        reference.unmount();
    // Delete current instance element
    if (rootEl)
        rootEl.remove();
    // Get component instance & reference
    const componentData = injectComponent(pluginOptions, component);
    // Assign new instance values
    reference = componentData.reference;
    instance = componentData.instance;
    toasts = instance.toasts;
};

/**
 * The following 4 functions are helpers.
 * base(), success(), warning(), error() accepts `message` as first argument, and `options` as a second one.
 */
var helperMethods = {
    base: (message, options = {}) => {
        push({
            type: 'base',
            message,
            ...options,
        });
    },
    success: (message, options = {}) => {
        push({
            type: 'success',
            message,
            ...options,
        });
    },
    warning: (message, options = {}) => {
        push({
            type: 'warning',
            message,
            ...options,
        });
    },
    error: (message, options = {}) => {
        push({
            type: 'error',
            message,
            ...options,
        });
    },
};

/**
 * Returns the toasts instance methods
 *
 * @returns VueMyToastsGlobalInstance instance
 */
const useToasts = () => ({
    toasts,
    push,
    remove,
    ...helperMethods,
    updateConfig,
});

const TimerMixin = {
    props: {
        duration: {
            type: Number,
            required: false,
            default: 3000, // Default timing: 3 seconds
        },
    },
    data: () => ({
        start: null,
        elapsed: null,
        hovered: false,
    }),
    computed: {
        /**
         * Return the elapsed timer percentage
         *
         * @returns { string }
         */
        percentageElapsed() {
            return ((this.elapsed / this.duration) * 100).toFixed(1);
        },
        /**
         * Return the remaining time as milliseconds
         *
         * @returns { number }
         */
        remaining() {
            return this.duration - this.elapsed;
        },
    },
    /**
     * Attach the event listeners for hovering management
     * and start the timer and requestAnimationFrame loop.
     */
    mounted() {
        // Don't use duration if it is set to 0.
        if (!this.duration || this.duration === 0)
            return;
        // Hover event
        this.$el.addEventListener('mouseover', () => {
            this.hovered = true;
        });
        // Mouse out event
        this.$el.addEventListener('mouseout', () => {
            this.hovered = false;
        });
        // Set start timestampp
        this.start = Date.now();
        // Initialize elapsed time
        this.elapsed = 0;
        // Start requestAnimationFrame loop
        requestAnimationFrame(this.updateTimer);
    },
    /**
     * Remove event listeners for hovering management
     */
    beforeUnmount() {
        // Don't use duration if it is set to 0.
        if (!this.duration || this.duration === 0)
            return;
        // Hover event
        this.$el.removeEventListener('mouseover', () => {
            this.hovered = true;
        });
        // Mouse out event
        this.$el.removeEventListener('mouseout', () => {
            this.hovered = false;
        });
    },
    methods: {
        /**
         * Update timer loop
         */
        updateTimer() {
            // Check if the toast is hovered
            if (!this.hovered) {
                // Update elapsed time
                this.elapsed = Date.now() - this.start;
                // Check if elapsed time is longer than showing duration
                if (this.elapsed >= this.duration) {
                    // Emit the `remove` event
                    this.$emit('remove');
                    return;
                }
            }
            else {
                // Pause the timer by keeping the elapsed time the same by updating started time
                this.start = Date.now() - this.elapsed;
            }
            // Call another aniationFrame
            requestAnimationFrame(this.updateTimer);
        },
    },
};

const ToastMixin = {
    props: {
        /**
         * The id of the toast
         */
        id: {
            type: String,
            required: true,
        },
        /**
         * The index of the toast in the current queue
         */
        index: {
            type: Number,
            required: true,
        },
        /**
         * Whether the width of the window is smaller than the specified width or not.
         */
        full: {
            type: Boolean,
            required: true,
        },
        /**
         * The type of the toast
         * Accepts: "base", "warning", "error", "success"
         */
        type: {
            type: String,
            required: false,
            default: 'base',
            validator: (x) => ['base', 'warning', 'error', 'success'].includes(x),
        },
        /**
         * The current position from the parent plugin options
         * Accepts: "bottom-right", "bottom-left", "top-right", "top-left", "top-middle", "bottom-middle"
         */
        position: {
            type: String,
            required: false,
            default: 'bottom-right',
            validator: (x) => [
                'bottom-right',
                'bottom-left',
                'top-right',
                'top-left',
                'top-middle',
                'bottom-middle',
            ].includes(x),
        },
        /**
         * The message to show on the toast
         */
        message: {
            type: String,
            required: true,
        },
    },
};

const defineToastComponent = (parameters, withTimer = true) => {
    const mixins = [ToastMixin];
    if (withTimer) {
        mixins.push(TimerMixin);
    }
    return vueDemi.defineComponent({
        ...parameters,
        mixins: [...(parameters.mixins || []), ...mixins],
    });
};

exports.currentComponent = undefined;
exports.pluginOptions = {
    width: '400px',
    padding: '1rem',
    position: 'bottom-right', // top-left, top-right, bottom-left, bottom-right, top-middle, bottom-middle
};
/**
 * Update the VueMyToasts options and reload instance.
 * @param newOptions
 * @param userComponent
 */
const updateConfig = (newOptions, userComponent) => {
    exports.pluginOptions = {
        ...exports.pluginOptions,
        ...newOptions,
    };
    if (userComponent) {
        exports.currentComponent = userComponent;
    }
    if (!exports.currentComponent) {
        console.warn('You need to specify a component for your toasts!');
        return;
    }
    updateConfig$1(exports.pluginOptions, exports.currentComponent);
};
/**
 * Vue plugin functions, default component and mixins
 *
 * @type {{
 *  install: install,
 *  version: string
 * }}
 */
const plugin = {
    /**
     * Install the plugin into Vue
     *
     * @param Vue
     * @param component
     * @param options
     */
    install: (app, { component, options }) => {
        // Overriding default config by user provided one
        exports.pluginOptions = {
            ...exports.pluginOptions,
            ...options,
        };
        // Initialize config
        updateConfig(exports.pluginOptions, component);
        // Generate VueMyToasts global instance
        const $toasts = {
            toasts,
            push,
            remove,
            ...helperMethods,
            updateConfig,
        };
        // Inject into Vue prototype
        app.provide('toasts', $toasts);
        app.config.globalProperties.$toasts = $toasts;
    },
};
// Try to auto-inject if Vue is loaded as a script tag.
if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(plugin);
}

exports.TimerMixin = TimerMixin;
exports.ToastMixin = ToastMixin;
exports.default = plugin;
exports.defineToastComponent = defineToastComponent;
exports.updateConfig = updateConfig;
exports.useToasts = useToasts;
